function [A,b,x] = my_construct_bpdn_instance(matrix,entries,options)
%function [A,b,x,tau,sigma,y,options] = construct_bpdn_instance(matrix,entries,lambda,options)
% Input:
%  matrix: Defines the model for the matrix. Note that some models are only
%     available in some sizes. Can be any of the following:
%     'gauss': Gives normally distributed entries with standard deviation 1.
%     'bernoulli': Gives +-1 entries with equal probabiliy.
%     'partdct': Gives a partial DCT matrix.
%     'heaviside': Gives an nxn spuare matrix with 1/n below the diagonal
%          and zero above.
%     'randorth': Given a matrix with random orthonormal rows.
%     'union_bases2': Union of two orthonormal bases. Gives [I dctmtx].
%     'union_bases3': Union of three orthonormal bases. Gives [I dctmtx M]
%          with an orthonormalized random matrix.
%  entries: Defines the model for the non-zero entries in the solution.
%     Could be either x directly or one of the following:
%     'bernoulli': Gives +-1 with equal probability.
%     'gauss': Gives normally distributed entries with standard deviation 1.
%     'dynamic1': Gives random entires with a dynamic range of 10
%     'dynamic2': Gives random entires with a dynamic range of 100
%     'dynamic3': Gives random entires with a dynamic range of 1.000
%     'dynamic4': Gives random entires with a dynamic range of 10.000
%     'dynamic5': Gives random entires with a dynamic range of 100.000
%     'appbernoulli': Gives entries which are generated by 
%           sign(randn(s,1)) + 0.1*randn(s,1) (i.e. "normally distributed
%           with standard variation 0.1 around +-1").
%  lambda: A positive number which is the regularization parameter in front
%     of the 1-norm.
%
% Optional input (for some matrix models restricted):
%  options: A struct containing optional input options. Set options = [] to
%  use the defaults.
%  options.dim        [k n] dimension of the matrix A (default [200 1000])
%         .sparsity   s the number of nonzero entries in x (default
%                     round(k/8))
%         .seed       Seed for the random number generator (for
%                     reproducible results, no default)
%         .scale      1='scale to norm(A)=1', 0='no scaling' (default 1)
%         .verbose    0=quiet, 1=some output (default 0)
%         .solver     Solver for the construction of y ('pocs',
%                     'conditional', 'projected', default 'pocs')
%         .maxiter    Maximal number of iteration for the solver (default:
%                     10*n)
%
% Output:
%  A: The k times n matrix.
%  b: The right hand side (a k vector).
%  x: An n vector which is the minimizer of
%      0.5||A*x-b||_2^2 + lambda*||x||_1.
%  tau: norm(x,1). Useful for tests of (LS_tau).
%  sigma: norm(A*x-b,2). Useful for tests of (BP_sigma).
%  y: Another k vector. Can be used the build new right hand sides for
%      different lambda and different x (which has the same sign pattern)
%      by b = lambda*y + A*x.
%  options: A struct containing the used options.
%
% Example usage:
%  1. A simple instance that most solvers can handle:
%  [A,b,x,tau,sigma,y] = construct_bpdn_instance('gauss','gauss',0.1);
%  2: A difficult instance
%  options.dim = [1000 2000];
%  options.sparsity = 350;
%  options.seed = 8741972;
%  [A,b,x,tau,sigma,y] = construct_bpdn_instance('partdct','dynamic5',...
%      0.001,options);
%
% @author: Dirk Lorenz, 08.02.2011, d.lorenz@tu-braunschweig.de
% @version: $Id: construct_bpdn_instance.m 4 2011-02-09 09:10:47Z dirloren $

if ~exist('options'), options = []; end
if ~isfield(options,'verbose'), options.verbose = 0; end
if ~isfield(options,'solver'), options.solver = 'pocs'; end
if ~isfield(options,'scale'), options.scale = 1; end
if ~isfield(options,'dim'), options.dim = [200 1000]; end
n = options.dim(2);
k = options.dim(1);
if ~isfield(options,'sparsity'), options.sparsity = round(k/8); end
s = options.sparsity;
if ~isfield(options,'maxiter'), options.maxiter = 10*n;end
if isfield(options,'seed'), 
    RandStream.setDefaultStream(RandStream('mt19937ar','seed',options.seed));
end



%% Construct matrix A
switch lower(matrix)
    case {'gauss'}
        if isempty(n)
            n = 1000;
        end
        if isempty(k)
            k = 200;
        end
        A = randn(k,n);
        if options.scale
            A = A/norm(A);
        end
    case {'bernoulli'}
        if isempty(n)
            n = 1000;
        end
        if isempty(k)
            k = 200;
        end
        A = sign(randn(k,n));
        if options.scale
            A = A/norm(A);
        end
    case {'partdct'}
        if isempty(n)
            n = 1000;
        end
        if isempty(k)
            k = 200;
        end
        [cc,rr] = meshgrid(0:n-1);
        C = sqrt(2 / n) * cos(pi * (2*cc + 1) .* rr / (2 * n));
        C(1,:) = C(1,:) / sqrt(2);
        p = randperm(n);
        A = C(p(1:k),:);

    case {'heaviside'}
        if isempty(n)
            n = 1000;
            k = n;
        end
        if ~isempty(n) && ~isempty(k) && n~=k
            error('n has to be equal to k for matrix heaviside')
        end
        A = triu(ones(n))/n;
        if options.scale
            A = A/norm(A);
        end
    case {'randorth'}
        if isempty(n)
            n = 1000;
        end
        if isempty(k)
            k = 200;
        end
        A = randn(k,n);
        A = orth(A')';
        if options.scale
            A = A/norm(A);
        end
        
        
    case {'union_bases2'}
        if isempty(n)
            n = 1024;
        elseif mod(n,2)
            error('n has to be even for matrix union_bases2')
        end
        
        if isempty(k)
            k = n/2;
        end
        if n~=2*k
            error('n has to be 2k for matrix union_bases2')
        end
        [cc,rr] = meshgrid(0:k-1);
        C = sqrt(2 / k) * cos(pi * (2*cc + 1) .* rr / (2 * k));
        C(1,:) = C(1,:) / sqrt(2);
        A = [eye(k) C];
        if options.scale
            A = A/norm(A);
        end
    case {'union_bases3'}
        if isempty(n)
            n = 1536;
        elseif mod(n,3)
            error('n/3 has to be integer for matrix union_basesr')
        end
        if isempty(k)
            k = n/3;
        end
        if n~=3*k
            error('n has to be 3k for matrix union_bases3')
        end
        [cc,rr] = meshgrid(0:k-1);
        C = sqrt(2 / k) * cos(pi * (2*cc + 1) .* rr / (2 * k));
        C(1,:) = C(1,:) / sqrt(2);
        
        B = randn(k);
        [Q,~] = qr(B);
        A = [eye(k) C Q];
        if options.scale
            A = A/norm(A);
        end
end


%% Construct vector x

x = zeros(n,1);
p = randperm(n);
    
if isnumeric(entries)
    s = sum(entries~=0);
    if s > k
        error('The number of nonzeros in x has to be smaller that k=options.dim(1).')
    end
    x = entries;
else
    if s>k
        error('The sparsity is not high enough: s=options.sparsity has to be smaller than k=options.dim(1).')
    end
    p = p(1:s);
    switch lower(entries)
        case {'gauss'}
            x(p) = randn(s,1);
        case {'bernoulli'}
            x(p) = sign(randn(s,1));
        case {'dynamic1'}
            x(p) = sign(randn(s,1)).*10.^rand(s,1);
        case {'dynamic2'}
            x(p) = sign(randn(s,1)).*10.^(2*rand(s,1));            
        case {'dynamic3'}
            x(p) = sign(randn(s,1)).*10.^(3*rand(s,1));  
        case {'dynamic4'}
            x(p) = sign(randn(s,1)).*10.^(4*rand(s,1));  
        case {'dynamic5'}
            x(p) = sign(randn(s,1)).*10.^(5*rand(s,1));  
        case {'appbernoulli'}
            x(p) = sign(randn(s,1)) + 0.1*randn(s,1);
    end
end


%% Construct b and y
b = A*x;
% [b,y] = construct_bpdn_rhs(A,x,lambda,'Verbose',options.verbose,'method',options.solver);
% tau = norm(x,1);
% sigma = norm(A*x-b,2);